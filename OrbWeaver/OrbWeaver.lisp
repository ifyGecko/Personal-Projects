;;;constants
(defconstant e 2.7182818284590452353602874713527)
(defconstant i #C(0 1))
(defconstant -i #C(0 -1))

;;;math function definitions
(defun cotan (expr) (/  1 (tan expr)))
(defun sec (expr) (/ 1 (cos expr)))
(defun csc (expr) (/ 1 (sin expr)))

(defun nlog-decimal (x)
"calulates the natural log of x using using a taylor series"
 (let ((sum 0))
  (flet ((taylor (n) (/ (expt (- x 1) n) n)))
  (loop for y from 1 to 150000 do (setf sum (+ sum (cond ((evenp y) (* -1 (taylor y)))
  	      	     	     	      	     	       (t (taylor y))))))) sum))
(defun nlog-integer (x)
"calculates the natural log of x using a taylor series"
  (let ((sum 0))
  (loop for y from 1 to 100 do (setf sum (+ sum (* (/ 1 y) (expt (/ (- x 1) x) y))))) sum))

(defun ln (x)
"computes the natural log of x dictated by if x is an integer or decimal number"
  (cond ((= (rem x 1) 0) (nlog-integer x))
  	(t (nlog-decimal x))))

;;;exponential definitions of inverse trig functions
;(defun acot (expr) (* (/ i 2) (- (ln (/ (- expr i) expr)) (ln (/ (+ expr i) expr)))))
;(defun asec (expr) (* -i (ln (+ (/ 1 expr) (* i (sqrt (- 1 (/ 1 (expt expr 2)))))))))
;(defun acsc (expr) (* -i (ln (+ (/ i expr) (sqrt (- 1 (/ 1 (expt expr 2))))))))

;;;supplimetary definitions of the inverse multiplicative inverse trig functions
;;;currently takes 3x's less cycles to compute than exponential definitions
(defun acot (expr) (atan (/ 1 expr)))
(defun asec (expr) (acos (/ 1 expr)))
(defun acsc (expr) (asin (/ 1 expr)))

;;;hyperbolic trig fucntions defined in terms of e
;(defun sinh (x) (/ (- (expt e (* 2 x)) 1) (* 2 (expt e x))))
;(defun cosh (x) (/ (+ (expt e (* 2 x)) 1) (* 2 (expt e x))))
;(defun tanh (x) (/ (sinh x) (cosh x)))
(defun coth (x) (/ (cosh x) (sinh x)))
(defun sech (x) (/ 1 (cosh x)))
(defun csch (x) (/ 1 (sinh x)))

;;;inverse hyperbolic trig functions defined in terms of natural log....need to add the restrictive conditions for x, ie x < 1
;(defun asinh (x) (ln (+ x (sqrt (+ (expt x 2) 1)))))
;(defun acosh (x) (ln (+ x (sqrt (- (expt x 2) 1)))))
;(defun atanh (x) (/ (ln (/ (+ 1 x) (- 1 x))) 2))
(defun acoth (x) (/ (ln (/ (+ x 1) (- x 1))) 2))
(defun asech (x) (ln (/ (+ 1 (sqrt (- 1 (expt x 2)))) x)))
(defun acsch (x) (ln (+ (/ 1 x) (sqrt (+ (/ 1 (expt x 2)) 1)))))

;;;predicate logic
(defun sump (expr) (and (consp expr) (eq '+ (car expr))))
(defun subtractionp (expr) (and (consp expr) (eq '- (car expr))))
(defun productp (expr) (and (consp expr) (eq '* (car expr))))
(defun quotientp (expr) (and (consp expr) (eq '/ (car expr))))
(defun exponentp (expr) (and (consp expr) (eq 'expt (car expr))))
(defun sinp (expr) (and (consp expr) (eq 'sin (car expr))))
(defun cosp (expr) (and (consp expr) (eq 'cos (car expr))))
(defun tanp (expr) (and (consp expr) (eq 'tan (car expr))))
(defun cotp (expr) (and (consp expr) (eq 'cot (car expr))))
(defun secp (expr) (and (consp expr) (eq 'sec (car expr))))
(defun cscp (expr) (and (consp expr) (eq 'csc (car expr))))
(defun lnp (expr) (and (consp expr) (eq 'ln (car expr))))
(defun logp (expr) (and (consp expr) (eq 'log (car expr))))
(defun asinp (expr) (and (consp expr) (eq 'asin (car expr))))
(defun acosp (expr) (and (consp expr) (eq 'acos (car expr))))
(defun atanp (expr) (and (consp expr) (eq 'atan (car expr))))
(defun asecp (expr) (and (consp expr) (eq 'asec (car expr))))
(defun acscp (expr) (and (consp expr) (eq 'acsc (car expr))))
(defun acotp (expr) (and (consp expr) (eq 'acot (car expr))))
(defun sinhp (expr) (and (consp expr) (eq 'sinh (car expr))))
(defun coshp (expr) (and (consp expr) (eq 'cosh (car expr))))
(defun tanhp (expr) (and (consp expr) (eq 'tanh (car expr))))
(defun cothp (expr) (and (consp expr) (eq 'coth (car expr))))
(defun sechp (expr) (and (consp expr) (eq 'sech (car expr))))
(defun cschp (expr) (and (consp expr) (eq 'csch (car expr))))

;;;form compositional definitions
(defun clean-expr (expr)
  "removes double nesting & nests w/floating variables"
 (cond ((numberp expr) expr)
       ((and (atom expr) (not (numberp expr)))
        (setf expr (list expr)))
       ((eq (cdr expr) nil)
        (setf expr (car expr)))))

(defun build-sum (a b)
  (clean-expr a) (clean-expr b)
  (cond ((equalp a 0) b)
    	((equalp b 0) a)
    	((and (numberp a) (numberp b)) (+ a b))
    	(t (list '+ a b))))

(defun build-subtraction (a b)
  (clean-expr a) (clean-expr b)
  (cond ((and (equalp a 0) (listp b)) (list '- b))
        ((equalp a 0) (- b))
	((equalp b 0) a)
       	((and (numberp a) (numberp b)) (- a b))
       	(t (list '- a b))))

(defun build-exponent (base exp)
  (clean-expr base) (clean-expr exp)
  (cond ((equalp exp 1) base)
	((equalp exp 0) 1)
	((equalp base 1) 1)
	((equalp base 0) 0)
	((and (numberp base) (numberp exp)) (expt base exp))
	(t (list 'expt base exp))))

(defun build-product (a b)
  (clean-expr a) (clean-expr b)
  (cond ((equalp a 1) b)
	((equalp b 1) a)
	((and (numberp a) (numberp b)) (* a b))
	((or (equalp a 0) (equalp b 0)) 0)
	((numberp b) (build-product b a))
	((and (numberp a) (exponentp b) (productp (cadr b)) (numberp (second (cadr b))))
	 (build-exponent (build-product (* a (second (cadr b))) (third (cadr b))) (caddr b)))
	((and (numberp a) (productp b) (numberp (cadr b)))
	 (build-product (* a (cadr b))
		       (caddr b)))
	(t (list '* a b))))

(defun build-quotient (a b)
  (clean-expr a) (clean-expr b)
  (cond ((equalp a b) 1)
	((equalp a 0) 0)
	((and (equalp a 1) (quotientp b)) (/ b a))
	((and (numberp a) (numberp b)) (/ a b))
	((equalp b 1) a)
       	((and (productp b) (eq a (cadr b)))
	 (build-quotient 1 (caddr b)))
	((and (numberp a) (and (productp b) (numberp (cadr b))))
	 (cond ((and (> a (cadr b)) (< 1 (gcd a (cadr b))))
	        (build-quotient (/ a (gcd a (cadr b))) (caddr b)))
	       ((and (< a (cadr b)) (< 1 (gcd a (cadr b))))
	        (build-quotient 1 (build-product (/ (cadr b) a) (caddr b))))
	       ((eq 0 (mod a (cadr b)))
	        (build-quotient (/ a (cadr b)) (caddr b)))))
	((and (numberp b) (and (productp a) (numberp (cadr a))))
	 (cond ((and (> (cadr a) b) (< 1 (gcd b (cadr a))))
	        (build-product (/ (cadr a) b) (caddr a)))
	       ((and (< (cadr a) b) (< 1 (gcd b (cadr a))))
	        (build-quotient (caddr a) (/ b (gcd b (cadr a)))))
	       ((eq 0 (mod (cadr a) b))
	        (build-quotient (caddr a) (/ (cadr a) b)))))
	((and (numberp b) (quotientp a) (numberp (cadr a)))
	 (build-quotient (/ b (cadr a)) (clean-expr (cddr a))))
	((and (numberp a) (quotientp b) (numberp (cadr b)))
	 (build-quotient (clean-expr (cddr b)) (/ a (cadr b))))
	((and (exponentp a) (exponentp b)) (build-exponent (cadr a) (- (caddr a) (caddr b))))
	((and (exponentp a) (not (listp b))) (build-exponent (cadr a) (- (caddr a) 1)))
	((and (not (listp a)) (exponentp b)) (build-exponent (cadr b) (- 1 (caddr b))))
       	(t (list '/ a b))))

(defun build-sin (expr)
  (clean-expr expr)
  (cond ((numberp expr) (sin expr))
	(t (list 'sin expr))))

(defun build-cos (expr)
  (clean-expr expr)
  (cond ((numberp expr) (cos expr))
	(t (list 'cos expr))))

(defun build-tan (expr)
  (clean-expr expr)
  (cond ((numberp expr) (tan expr))
	(t (list 'tan expr))))

(defun build-cot (expr)
  (clean-expr expr)
  (cond ((numberp expr) (cotan expr))
        (t (list 'cot expr))))

(defun build-sec (expr)
  (clean-expr expr)
  (cond ((numberp expr) (sec expr))
        (t (list 'sec expr))))

(defun build-csc (expr)
  (clean-expr expr)
  (cond ((numberp expr) (csc expr))
        (t (list 'csc expr))))

(defun build-ln (expr)
  (clean-expr expr)
  (cond ((eq 'e expr) 1)
        (t (list 'ln expr))))

(defun build-log (base exp)
  (clean-expr base) (clean-expr exp)
  (cond ((eq base 'e) (build-ln exp))
        (t (list 'log base exp))))

(defun build-asin (expr)
  (clean-expr expr)
  (cond ((numberp expr) (asin expr))
        (t (list 'asin expr))))

(defun build-acos (expr)
  (clean-expr expr)
  (cond ((numberp expr) (acos expr))
        (t (list 'acos expr))))

(defun build-atan (expr)
  (clean-expr expr)
  (cond ((numberp expr) (atan expr))
        (t (list 'atan expr))))

(defun build-asec (expr)
  (clean-expr expr)
  (cond ((numberp expr) (asec expr))
	(t (list 'asec expr))))

(defun build-acsc (expr)
  (clean-expr expr)
  (cond ((numberp expr) (acsc expr))
	(t (list 'acsc expr))))

(defun build-acot (expr)
  (clean-expr expr)
  (cond ((numberp expr) (acot expr))
	(t (list 'acot expr))))
    
(defun build-sqrt (expr)
  (clean-expr expr)
  (cond ((numberp expr) (sqrt expr))
	(t (list 'sqrt expr))))

(defun build-negative (expr)
  (build-product -1 expr))

(defun build-abs (expr)
  (list 'abs expr))

(defun build-sinh (expr)
  (list 'sinh expr))

(defun build-cosh (expr)
  (list 'cosh expr))

(defun build-tanh (expr)
  (list 'tanh expr))

(defun build-coth (expr)
  (list 'coth expr))

(defun build-sech (expr)
  (list 'sech expr))

(defun build-csch (expr)
  (list 'csch expr))

(defun derivative (expr var)
  "applies rules to compose the derivative of an expression"
  (cond ((atom expr) (setf expr (list expr))))
  (let ((x (cadr expr))
        (y (caddr expr)))
  (clean-expr x) (clean-expr y)
  (cond ((numberp (car expr)) 0)
	((eq (car expr) var) 1)
	((sump expr) (build-sum (derivative x var) (derivative y var)))
	((subtractionp expr) (build-subtraction (derivative x var) (derivative y var)))
	((productp expr)
	   (build-sum (build-product y (derivative x var))
		     (build-product x (derivative y var))))
	((quotientp expr)
	 (cond ((numberp x) 0)
	       ((and (exponentp x) (exponentp y)) (derivative (build-exponent var (- (caddr x) (caddr y))) var))
	       ((and (exponentp x) (not (listp y))) (derivative (build-exponent var (- (caddr x) 1)) var))
	       ((and (not (listp x)) (exponentp y)) (derivative (build-exponent var (- 1 (caddr y))) var))
	       ((eq y 1) (build-negative (build-quotient (derivative x var) (build-exponent x 2))))
	       ((and (listp x) (numberp y)) (build-quotient (derivative x var) y))
	       (t (build-quotient (build-subtraction
				    (build-product x (derivative y var))
				    (build-product y (derivative x var)))
				   (build-exponent y 2)))))
       ((sinp expr)
	   (cond ((numberp x) 0)
	         ((listp x) (build-product (build-cos x) (derivative x var)))
	   	 (t (build-cos x))))
       ((cosp expr)
	 (cond ((numberp x) 0)
	       ((listp x) (build-product (build-negative (build-sin x)) (derivative x var)))
	       (t (build-negative (build-sin (cdr expr))))))
       ((tanp expr)
	   (cond ((numberp x) 0)
	   	 ((listp x) (build-product (build-exponent (build-sec x) 2) (derivative x var)))
	   	 (t (build-exponent (build-sec x) 2))))
       ((cotp expr)
	   (cond ((numberp x) 0)
	         ((listp x) (build-product (build-negative (build-exponent (build-csc x) 2)) (derivative x var)))
	         (t (build-negative (build-exponent (build-csc x) 2)))))
       ((cscp expr)
	   (cond ((numberp x) 0)
	         ((listp x) (build-product (build-negative (build-product (build-csc x) (build-cot x))) (derivative x var)))
	   	 (t (build-negative (build-product (build-csc x) (build-cot x))))))
       ((secp expr)
	   (cond ((numberp x) 0)
	         ((listp x) (build-product (build-product (build-sec x) (build-tan x)) (derivative x var)))
	         (t (build-product (build-sec x) (build-tan x)))))
       ((lnp expr)
	   (cond ((numberp x) 0)
	         ((productp x)
	   	  (build-sum (derivative (build-ln (second x)) var)
		            (derivative (build-ln (third x)) var)))
		 ((quotientp x)
		  (build-subtraction (derivative (build-ln (second x)) var)
		                    (derivative (build-ln (third x)) var)))
		 (t (build-quotient (derivative x var) x))))
       ((logp expr)
	 (cond ((numberp x) 0)
	       (t (build-quotient 1 (build-product x (build-ln y))))))
       ((asinp expr)
	 (cond ((numberp x) 0)
	       (t (build-quotient (derivative x var) (build-sqrt (build-sum 1 (build-exponent x 2)))))))
       ((acosp expr)
	 (cond ((numberp x) 0)
	       (t (build-negative (build-quotient (derivative x var) (build-sqrt (build-sum 1 (build-exponent x 2))))))))
       ((atanp expr)
	 (cond ((numberp x) 0)
	       (t (build-quotient (derivative x var) (build-sum 1 (build-exponent x 2))))))
       ((acscp expr)
	 (cond ((numberp x) 0)
	       (t (build-negative (build-quotient (derivative x var) (build-product x
	       	  		 (build-sqrt (build-subtraction (build-exponent x 2) 1))))))))
       ((asecp expr)
	 (cond ((numberp x) 0)
	       (t (build-quotient (derivative x var) (build-product (build-abs x)
	       	  		   (build-sqrt (build-subtraction (build-exponent x 2) 1)))))))
       ((acotp expr)
	 (cond ((numberp x) 0)
	       (t (build-negative (build-quotient (derivative x var) (build-sum 1 (build-exponent x 2)))))))
       ((sinhp expr)
	 (cond ((numberp x) 0)
	       (t (build-cosh x))))
       ((coshp expr)
	 (cond ((numberp x) 0)
	       (t (build-sinh x))))
       ((tanhp expr)
	 (cond ((numberp x) 0)
	       (t (build-exponent (build-sech x) 2))))
       ((cothp expr)
	 (cond ((and (numberp x) (not (= x 0))) 0)
	       ((= x 0) (print "coth(0) can not be differentiated"))
	       (t (build-negative (build-exponent (build-csch x) 2)))))
       ((sechp expr)
	 (cond ((numberp x) 0)
	       (t (build-negative (build-product (build-tanh x) (build-sech x))))))
       ((cschp expr)
	 (cond ((and (numberp x) (not (= x 0))) 0)
	       ((= x 0) (print "csch(0) can not be differentiated"))
	       (t (build-negative (build-product (build-coth x) (build-csch x))))))
       ((exponentp expr)
	   (cond ((and (numberp x) (numberp y)) 0)
		 ((eq y -1) (build-product -1 (build-quotient (derivative x var) (build-exponent x 2))))
	   	 ((eq y 1) (derivative x var))
		 ((eq x 'e) (build-product (derivative y var) (build-exponent x y)))
		 ((and (eq x 'e) (lnp y)) (cdr y))
		 ((and (numberp x) (numberp y)) (expt x y))
 		 ((and (listp x) (numberp y)) (build-product y (build-product (build-exponent x (- y 1)) (derivative x var))))
		 ((listp y) (build-product expr (build-ln x)))
		 ((numberp y) (build-product y (build-exponent x (- y 1)))))))))

(defun debugger (x)
  "used to trace the key functions used in the derivative function"
  (cond ((eq x 1)
	        (trace derivative clean-expr build-negative)
		(trace build-sum build-subtraction)
		(trace build-product build-quotient build-exponent build-sqrt)
		(trace build-sin build-cos build-tan)
		(trace build-cot build-sec build-csc)
		(trace build-log build-ln)
		(trace build-atan build-asin build-acos)
		(trace sump subtractionp quotientp productp)
		(trace sinp cosp tanp secp cscp cotp atanp asinp acosp asecp acscp acotp)
		(trace logp lnp exponentp)
		(trace sinhp coshp tanhp cothp sechp cschp)
		(trace build-sinh build-cosh build-tanh build-coth build-sech build-csch))
	((eq x 0)
	        (untrace derivative clean-expr build-negative)
		(untrace build-sum build-subtraction)
		(untrace build-product build-quotient build-exponent build-sqrt)
		(untrace build-sin build-cos build-tan)
		(untrace build-cot build-sec build-csc)
		(untrace build-log build-ln)
		(untrace build-atan build-asin build-acos)
	        (untrace sump subtractionp quotientp productp)
		(untrace sinp cosp tanp secp cscp cotp atanp asinp acosp asecp acscp acotp)
		(untrace logp lnp exponentp)
		(untrace sinhp coshp tanhp cothp sechp cschp)
		(untrace build-sinh build-cosh build-tanh build-coth build-sech build-csch))
	(t (print "(debugger 1) enables tracing/(debugger 0) disables tracing"))))
		
